CREATE TABLE IF NOT EXISTS candles (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    pair VARCHAR(13) NOT NULL,
    open_time TIMESTAMPTZ AS kotlinx.datetime.Instant NOT NULL,
    close_time TIMESTAMPTZ AS kotlinx.datetime.Instant NOT NULL,
    trades INTEGER NOT NULL DEFAULT 0,
    open_price DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    high_price DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    low_price DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    close_price DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    volume DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    updated_at TIMESTAMPTZ AS kotlinx.datetime.Instant NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_pair_open_close_time UNIQUE (pair, open_time, close_time)
);

-- queries

getAll:
SELECT * FROM candles;

getById:
SELECT * FROM candles
WHERE id = :id;

getByPair:
SELECT * FROM candles
WHERE pair = :pair;

getByPairInterval:
SELECT
    :minutes * 60 * FLOOR(EXTRACT(EPOCH FROM open_time) / (:minutes * 60)) AS grp_id,
    pair,
    MIN(open_time) AS open_time,
    MAX(close_time) AS close_time,
	SUM(trades) AS trades,
  	ARRAY_AGG(open_price ORDER BY open_time ASC) AS open_price,
  	ARRAY_AGG(close_price ORDER BY open_time DESC) AS close_price,
    MIN(low_price) AS low_price,
    MAX(high_price) AS high_price,
    SUM(volume) AS volume,
    MAX(updated_at) AS updated_at
FROM
    candles
WHERE
    pair = :pair
    AND open_time >= :time
GROUP BY
    pair, grp_id
ORDER BY
    grp_id;

insert:
INSERT INTO candles (
    pair, open_time, close_time, trades, open_price, high_price, low_price, close_price, volume, updated_at
) VALUES (
    :pair, :openTime, :closeTime, :trades, :openPrice, :highPrice, :lowPrice, :closePrice, :volume, CURRENT_TIMESTAMP
)
ON CONFLICT (pair, open_time, close_time) DO UPDATE SET
    trades = excluded.trades,
    open_price = excluded.open_price,
    high_price = excluded.high_price,
    low_price = excluded.low_price,
    close_price = excluded.close_price,
    volume = excluded.volume,
    updated_at = excluded.updated_at;