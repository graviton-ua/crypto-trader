CREATE TABLE IF NOT EXISTS ohlcv (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    pair VARCHAR(13) NOT NULL,
    open_time TIMESTAMPTZ AS kotlinx.datetime.Instant NOT NULL,
    close_time TIMESTAMPTZ AS kotlinx.datetime.Instant NOT NULL,
    trades INTEGER NOT NULL DEFAULT 0,
    open_price DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    high_price DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    low_price DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    close_price DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    volume DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    updated_at TIMESTAMPTZ AS kotlinx.datetime.Instant NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_pair_open_close_time UNIQUE (pair, open_time, close_time)
);

-- queries

getAll:
SELECT * FROM ohlcv;

getForId:
SELECT * FROM ohlcv
WHERE id = :id;

getForPair:
SELECT * FROM ohlcv
WHERE pair = :pair;

getClosedForEachMinute:
SELECT ohlcv.id, ohlcv.pair, ohlcv.open_time, ohlcv.close_time, ohlcv.trades,
    ohlcv.open_price, ohlcv.high_price, ohlcv.low_price, ohlcv.close_price,
    ohlcv.volume, ohlcv.updated_at
FROM ohlcv
JOIN (
    SELECT
        pair,
        close_time,
        MAX(updated_at) AS timestamp
    FROM ohlcv
    WHERE pair = ?
    GROUP BY pair, close_time
) AS LatestRows
ON ohlcv.pair = LatestRows.pair
   AND ohlcv.close_time = LatestRows.close_time
   AND ohlcv.updated_at = LatestRows.timestamp
ORDER BY ohlcv.close_time ASC;

insert:
INSERT INTO ohlcv (
    pair, open_time, close_time, trades, open_price, high_price, low_price, close_price, volume, updated_at
) VALUES (
    :pair, :openTime, :closeTime, :trades, :openPrice, :highPrice, :lowPrice, :closePrice, :volume, CURRENT_TIMESTAMP
)
ON CONFLICT (pair, open_time, close_time) DO UPDATE SET
    trades = excluded.trades,
    open_price = excluded.open_price,
    high_price = excluded.high_price,
    low_price = excluded.low_price,
    close_price = excluded.close_price,
    volume = excluded.volume,
    updated_at = excluded.updated_at;